<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber-Event Toolkit</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; color: #0ff; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 100%),
                        repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0, 255, 255, 0.03) 2px, transparent 3px);
            background-size: 100% 100%, 100% 4px;
            animation: scanline 6s linear infinite;
        }
        @keyframes scanline { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

        /* UI Elements */
        .hud { position: absolute; z-index: 3; padding: 20px; font-size: 14px; text-shadow: 0 0 5px #0ff; pointer-events: none; }
        .top-left { top: 0; left: 0; }
        .top-right { top: 0; right: 0; text-align: right; }
        .bottom-left { bottom: 0; left: 0; }
        .bottom-right { bottom: 0; right: 0; text-align: right; }
        .hud-label { color: #0ff; font-weight: bold; display: block; margin-bottom: 5px; }
        .hud-value { color: #fff; font-size: 18px; }

        /* Panel Container */
        #control-panel {
            display: none;
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 600px; height: 500px;
            background: rgba(0, 10, 20, 0.95);
            border: 1px solid #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            z-index: 20;
            display: flex;
            flex-direction: column;
        }

        .panel-header { display: flex; border-bottom: 1px solid #0ff; }
        .tab-btn {
            flex: 1; background: transparent; border: none; color: #0ff; padding: 15px;
            font-family: 'Orbitron', sans-serif; cursor: pointer; font-weight: bold;
            transition: background 0.3s;
        }
        .tab-btn:hover { background: rgba(0, 255, 255, 0.1); }
        .tab-btn.active { background: rgba(0, 255, 255, 0.3); color: #fff; }

        .panel-content { flex: 1; padding: 20px; overflow-y: auto; text-align: left; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .setting-row { margin-bottom: 15px; }
        .setting-label { display: block; color: #0ff; font-size: 12px; margin-bottom: 5px; }
        .setting-input, .setting-textarea {
            width: 100%; background: rgba(0, 255, 255, 0.05); border: 1px solid #0ff;
            color: #fff; padding: 8px; font-family: 'Orbitron', sans-serif; box-sizing: border-box;
        }
        .setting-textarea { height: 100px; resize: vertical; }

        #toggle-panel-btn {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 10; background: rgba(0, 255, 255, 0.1); border: 1px solid #0ff;
            color: #0ff; padding: 10px 20px; font-family: 'Orbitron', sans-serif;
            cursor: pointer; text-transform: uppercase; font-weight: bold;
        }
        #toggle-panel-btn:hover { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 15px #0ff; }

        #input-video {
            display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: 0; transform: scaleX(-1);
            filter: brightness(0.25) contrast(1.1);
        }
        #text-canvas, #image-canvas { display: none; }
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #0ff; font-size: 24px; z-index: 10; text-align: center;
        }

        .mode-indicator {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #0ff; z-index: 5;
        }
        .keyboard-hint {
            position: absolute; bottom: 20px; right: 20px; text-align: right;
            color: rgba(0, 255, 255, 0.7); font-size: 12px; z-index: 5; pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="loading" id="loading">INITIALIZING SYSTEM...<br>Please allow camera access</div>

    <div id="canvas-container"></div>
    <div class="overlay"></div>
    <div class="mode-indicator" id="mode-display">MODE: FREE FLOW</div>
    <div class="keyboard-hint" id="key-hints">
        [TAB] Settings | [SPACE] Spin | [ENTER] Reveal
    </div>

    <!-- HUD -->
    <div class="hud top-left">
        <span class="hud-label">FPS</span><span class="hud-value" id="fps">0</span>
    </div>
    <div class="hud top-right">
        <span class="hud-label">PARTICLES</span><span class="hud-value">12,000</span>
    </div>
    <div class="hud bottom-left">
        <span class="hud-label">LEFT HAND</span><span class="hud-value" id="left-status">OFFLINE</span>
    </div>
    <div class="hud bottom-right">
        <span class="hud-label">RIGHT HAND</span><span class="hud-value" id="right-status">OFFLINE</span>
    </div>

    <button id="toggle-panel-btn" onclick="app.ui.togglePanel()">CONTROL PANEL</button>

    <!-- Control Panel -->
    <div id="control-panel" style="display:none;">
        <div class="panel-header">
            <button class="tab-btn active" onclick="app.ui.switchTab('general')">GENERAL</button>
            <button class="tab-btn" onclick="app.ui.switchTab('welcome')">WELCOME WALL</button>
            <button class="tab-btn" onclick="app.ui.switchTab('lottery')">LOTTERY</button>
            <button class="tab-btn" onclick="app.ui.switchTab('voting')">VOTING</button>
        </div>

        <div class="panel-content">
            <!-- General Tab -->
            <div id="tab-general" class="tab-content active">
                <div class="setting-row">
                    <span class="setting-label">Hand Mapping</span>
                    <label style="color:#fff; display:flex; align-items:center; cursor:pointer;">
                        <input type="checkbox" id="swap-hands" onchange="app.config.set('swapHands', this.checked)" style="margin-right:10px;">
                        Swap Left/Right Hands
                    </label>
                </div>
                <div class="setting-row">
                    <span class="setting-label">1 Finger Text</span>
                    <input type="text" class="setting-input" id="cmd-1" oninput="app.config.updateCmd(1, this.value)">
                </div>
                <div class="setting-row">
                    <span class="setting-label">2 Fingers Text</span>
                    <input type="text" class="setting-input" id="cmd-2" oninput="app.config.updateCmd(2, this.value)">
                </div>
                 <div class="setting-row">
                    <span class="setting-label">3 Fingers Text</span>
                    <input type="text" class="setting-input" id="cmd-3" oninput="app.config.updateCmd(3, this.value)">
                </div>
                 <div class="setting-row">
                    <span class="setting-label">4 Fingers Text</span>
                    <input type="text" class="setting-input" id="cmd-4" oninput="app.config.updateCmd(4, this.value)">
                </div>
            </div>

            <!-- Welcome Tab -->
            <div id="tab-welcome" class="tab-content">
                <div class="setting-row">
                    <span class="setting-label">Welcome Message</span>
                    <input type="text" class="setting-input" id="welcome-msg" value="WELCOME" oninput="app.config.set('welcomeMsg', this.value)">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Logo Upload (Image)</span>
                    <input type="file" class="setting-input" id="logo-upload" accept="image/*" onchange="app.particleSystem.loadLogo(this)">
                </div>
            </div>

            <!-- Lottery Tab -->
            <div id="tab-lottery" class="tab-content">
                <div class="setting-row">
                    <span class="setting-label">Prize List (One per line)</span>
                    <textarea class="setting-textarea" id="lottery-list" oninput="app.config.set('lotteryList', this.value)">MacBook Pro
iPhone 15
Tesla Model 3
Coffee Mug
Paid Vacation</textarea>
                </div>
                <button class="setting-input" onclick="app.logic.triggerLotterySpin()">TEST SPIN</button>
            </div>

             <!-- Voting Tab -->
            <div id="tab-voting" class="tab-content">
                <div class="setting-row">
                    <span class="setting-label">Option A (Key 'A')</span>
                    <input type="text" class="setting-input" value="Option A" id="vote-a">
                    <button class="setting-input" style="margin-top:5px" onclick="app.logic.triggerVote('A')">REVEAL OPTION A</button>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Option B (Key 'B')</span>
                    <input type="text" class="setting-input" value="Option B" id="vote-b">
                    <button class="setting-input" style="margin-top:5px" onclick="app.logic.triggerVote('B')">REVEAL OPTION B</button>
                </div>
            </div>
        </div>
    </div>

    <video id="input-video"></video>
    <canvas id="text-canvas"></canvas>
    <canvas id="image-canvas"></canvas>

<script>
/**
 * CYBER-EVENT TOOLKIT
 * Modular Architecture
 */

// --- 1. CONFIG MANAGER ---
class ConfigManager {
    constructor() {
        this.data = {
            particleCount: 12000,
            particleSize: 2.4,
            lerpSpeed: 0.16,
            repulsionRadius: 80,
            repulsionForce: 5.0,
            colors: {
                blue: new THREE.Color(0x00FFFF),
                yellow: new THREE.Color(0xFFFF00),
                pink: new THREE.Color(0xFF00FF),
                green: new THREE.Color(0x00FF88),
                orange: new THREE.Color(0xFFA500),
                white: new THREE.Color(0xFFFFFF),
                red: new THREE.Color(0xFF0000)
            },
            commands: {
                1: "Hello",
                2: "Gemini3",
                3: "非常好用",
                4: "再见"
            },
            welcomeMsg: "WELCOME",
            swapHands: false,
            lotteryList: "Prize 1\nPrize 2\nPrize 3"
        };
        this.load();
    }

    load() {
        const saved = localStorage.getItem('cyber_config');
        if (saved) {
            const parsed = JSON.parse(saved);
            // Merge strictly
            if(parsed.commands) this.data.commands = parsed.commands;
            if(parsed.welcomeMsg) this.data.welcomeMsg = parsed.welcomeMsg;
            if(parsed.lotteryList) this.data.lotteryList = parsed.lotteryList;
            if(parsed.swapHands !== undefined) this.data.swapHands = parsed.swapHands;
        }
        // Initialize UI values
        document.getElementById('cmd-1').value = this.data.commands[1];
        document.getElementById('cmd-2').value = this.data.commands[2];
        document.getElementById('cmd-3').value = this.data.commands[3];
        document.getElementById('cmd-4').value = this.data.commands[4];
        document.getElementById('welcome-msg').value = this.data.welcomeMsg;
        document.getElementById('lottery-list').value = this.data.lotteryList;
        document.getElementById('swap-hands').checked = this.data.swapHands;
    }

    save() {
        localStorage.setItem('cyber_config', JSON.stringify({
            commands: this.data.commands,
            welcomeMsg: this.data.welcomeMsg,
            lotteryList: this.data.lotteryList,
            swapHands: this.data.swapHands
        }));
    }

    set(key, value) {
        this.data[key] = value;
        this.save();
    }

    updateCmd(finger, value) {
        this.data.commands[finger] = value;
        this.save();
        if (app.input.state.leftHand.mode !== 'IDLE' && app.input.state.leftHand.fingers == finger) {
            app.particleSystem.updateTargets('TEXT', value);
        }
    }
}

// --- 2. SCENE MANAGER ---
class SceneManager {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.camera.position.z = 600;

        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);

        window.addEventListener('resize', () => this.onResize());
    }

    onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    render() {
        this.renderer.render(this.scene, this.camera);
    }
}

// --- 3. PARTICLE SYSTEM ---
class ParticleSystem {
    constructor(config, scene) {
        this.config = config;
        this.scene = scene;
        this.count = config.particleCount;

        // Geometry
        this.geometry = new THREE.BufferGeometry();
        this.posArray = new Float32Array(this.count * 3);
        this.targetArray = new Float32Array(this.count * 3);
        this.colorArray = new Float32Array(this.count * 3);
        this.targetColorArray = new Float32Array(this.count * 3); // New: Target colors
        this.bouncePhaseArray = new Float32Array(this.count);

        // Init
        for(let i=0; i<this.count; i++) {
            const i3 = i*3;
            // ... (pos init)
            this.posArray[i3] = (Math.random()-0.5)*1000;
            this.posArray[i3+1] = (Math.random()-0.5)*1000;
            this.posArray[i3+2] = (Math.random()-0.5)*1000;

            this.targetArray[i3] = this.posArray[i3];
            this.targetArray[i3+1] = this.posArray[i3+1];
            this.targetArray[i3+2] = this.posArray[i3+2];

            const c = this.config.colors.blue;
            this.colorArray[i3] = c.r;
            this.colorArray[i3+1] = c.g;
            this.colorArray[i3+2] = c.b;

            // Init target color
            this.targetColorArray[i3] = c.r;
            this.targetColorArray[i3+1] = c.g;
            this.targetColorArray[i3+2] = c.b;

            this.bouncePhaseArray[i] = Math.random() * Math.PI * 2;
        }

        this.geometry.setAttribute('position', new THREE.BufferAttribute(this.posArray, 3));
        this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colorArray, 3));

        // Material
        this.material = new THREE.PointsMaterial({
            size: this.config.particleSize,
            map: this.getSprite(),
            transparent: true,
            opacity: 0.9,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        this.mesh = new THREE.Points(this.geometry, this.material);
        this.scene.add(this.mesh);

        // Utils
        this.textCanvas = document.getElementById('text-canvas');
        this.textCanvas.width = 800;
        this.textCanvas.height = 600;
        this.ctx = this.textCanvas.getContext('2d');

        this.basketballPoints = this.generateBasketballPoints();
        this.activeColor = this.config.colors.blue;
    }

    getSprite() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0,0,32,32);
        return new THREE.CanvasTexture(canvas);
    }

    generateBasketballPoints() {
        const points = [];
        const count = 6000;
        const radius = 100;
        const phi = Math.PI * (3 - Math.sqrt(5));
        for(let i=0; i<count; i++) {
            const y = 1 - (i / (count-1))*2;
            const r = Math.sqrt(1-y*y);
            const theta = phi * i;
            const x = Math.cos(theta)*r;
            const z = Math.sin(theta)*r;

            // Rejection sampling for lines
            const lineThickness = 0.08;
            if(Math.abs(x) < lineThickness) continue;
            if(Math.abs(z) < lineThickness) continue;

            points.push(new THREE.Vector3(x*radius, y*radius, z*radius));
        }
        return points;
    }

    generateTextTargets(text) {
        this.ctx.clearRect(0,0,800,600);
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0,0,800,600);
        this.ctx.font = 'bold 75px "Orbitron"';
        this.ctx.fillStyle = '#fff';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';

        const lines = text.split('\n');
        const lineHeight = 90;
        const startY = (600 - (lines.length-1)*lineHeight)/2;
        lines.forEach((l,i) => this.ctx.fillText(l, 400, startY + i*lineHeight));

        const data = this.ctx.getImageData(0,0,800,600).data;
        const points = [];
        for(let y=0; y<600; y+=3) {
            for(let x=0; x<800; x+=3) {
                if(data[(y*800+x)*4] > 128) {
                    points.push({
                        x: (x-400)*1.5,
                        y: -(y-300)*1.5,
                        z: 0
                    });
                }
            }
        }
        return points;
    }

    loadLogo(input) {
        if(input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    this.logoPoints = this.generateImageTargets(img);
                    this.updateTargets('LOGO');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(input.files[0]);
        }
    }

    generateImageTargets(img) {
         // Re-use text canvas
         this.ctx.clearRect(0,0,800,600);
         // Scale to fit
         const scale = Math.min(800/img.width, 600/img.height) * 0.8;
         const w = img.width * scale;
         const h = img.height * scale;
         this.ctx.drawImage(img, 400-w/2, 300-h/2, w, h);

         const data = this.ctx.getImageData(0,0,800,600).data;
         const points = [];
         const step = 4; // optimization
         for(let y=0; y<600; y+=step) {
            for(let x=0; x<800; x+=step) {
                const idx = (y*800+x)*4;
                if(data[idx+3] > 128) { // Alpha check
                    points.push({
                        x: (x-400)*1.5,
                        y: -(y-300)*1.5,
                        z: 0,
                        c: new THREE.Color(data[idx]/255, data[idx+1]/255, data[idx+2]/255)
                    });
                }
            }
         }
         return points;
    }

    updateTargets(mode, data) {
        let points = [];
        if(mode === 'TEXT') points = this.generateTextTargets(data);
        else if(mode === 'BASKETBALL') points = this.basketballPoints;
        else if(mode === 'LOGO' && this.logoPoints) points = this.logoPoints;

        this.currentTargetMode = mode;

        for(let i=0; i<this.count; i++) {
            const i3 = i*3;
            if(mode === 'NEBULA') {
                this.targetArray[i3] = (Math.random()-0.5)*800;
                this.targetArray[i3+1] = (Math.random()-0.5)*800;
                this.targetArray[i3+2] = (Math.random()-0.5)*800;
            } else {
                if(points.length > 0) {
                    const p = points[i % points.length];
                    this.targetArray[i3] = p.x;
                    this.targetArray[i3+1] = p.y;
                    this.targetArray[i3+2] = p.z || 0;

                    // Update Target Color if available (for Logo)
                    if(p.c) {
                        this.targetColorArray[i3] = p.c.r;
                        this.targetColorArray[i3+1] = p.c.g;
                        this.targetColorArray[i3+2] = p.c.b;
                    }
                } else {
                     this.targetArray[i3] = 0; this.targetArray[i3+1] = 0; this.targetArray[i3+2] = 0;
                }
            }
        }
    }

    setColors(color) {
        this.activeColor = color; // For global override
        this.useGlobalColor = true;
        // Update all targets to this global color
        for(let i=0; i<this.count; i++) {
            const i3 = i*3;
            this.targetColorArray[i3] = color.r;
            this.targetColorArray[i3+1] = color.g;
            this.targetColorArray[i3+2] = color.b;
        }
    }

    update(time, handState) {
        const positions = this.geometry.attributes.position.array;
        const colors = this.geometry.attributes.color.array;

        for(let i=0; i<this.count; i++) {
            const i3 = i*3;
            // ... (physics)
            let px = positions[i3];
            let py = positions[i3+1];
            let pz = positions[i3+2];

            let tx, ty, tz;

            // --- TARGET LOGIC ---
            if(handState.isUltimateMode) {
                const p = this.basketballPoints[i % this.basketballPoints.length];
                const angle = time * 2;
                const rx = p.x * Math.cos(angle) - p.z * Math.sin(angle);
                const rz = p.x * Math.sin(angle) + p.z * Math.cos(angle);

                tx = handState.leftHand.position.x + rx;
                ty = handState.leftHand.position.y + p.y;
                tz = handState.leftHand.position.z + rz;

                // Bounce
                ty += Math.abs(Math.sin(time*5 + this.bouncePhaseArray[i])) * 50;
            } else if (handState.rightHand.mode === 'NEBULA') {
                tx = this.targetArray[i3];
                ty = this.targetArray[i3+1];
                tz = this.targetArray[i3+2];
                // Ripple
                if(handState.rightHand.present) {
                    const dist = Math.sqrt(
                        Math.pow(px - handState.rightHand.indexTip.x, 2) +
                        Math.pow(py - handState.rightHand.indexTip.y, 2) +
                        Math.pow(pz - 0, 2)
                    );
                    pz += Math.sin(dist*0.05 - time*10) * 20;
                }
            } else {
                 tx = this.targetArray[i3];
                 ty = this.targetArray[i3+1];
                 tz = this.targetArray[i3+2];
            }

            // --- PHYSICS LERP ---
            px += (tx - px) * this.config.lerpSpeed;
            py += (ty - py) * this.config.lerpSpeed;
            pz += (tz - pz) * this.config.lerpSpeed;

            // --- INTERACTION (Right Hand Repulsion) ---
            if(handState.rightHand.present && handState.rightHand.mode === 'POINT' && !handState.isUltimateMode) {
                 const dx = px - handState.rightHand.indexTip.x;
                 const dy = py - handState.rightHand.indexTip.y;
                 const dist = Math.sqrt(dx*dx + dy*dy);
                 if(dist < this.config.repulsionRadius) {
                     const force = (this.config.repulsionRadius - dist) * this.config.repulsionForce;
                     const angle = Math.atan2(dy, dx);
                     px += Math.cos(angle) * force;
                     py += Math.sin(angle) * force;
                 }
            }

            positions[i3] = px; positions[i3+1] = py; positions[i3+2] = pz;

            // --- COLOR LERP ---
            // Lerp towards targetColorArray
            const tr = this.targetColorArray[i3];
            const tg = this.targetColorArray[i3+1];
            const tb = this.targetColorArray[i3+2];

            colors[i3] += (tr - colors[i3]) * 0.1;
            colors[i3+1] += (tg - colors[i3+1]) * 0.1;
            colors[i3+2] += (tb - colors[i3+2]) * 0.1;
        }

        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.color.needsUpdate = true;
    }
}

// --- 4. INPUT CONTROLLER ---
class InputController {
    constructor() {
        this.state = {
            leftHand: { present: false, fingers: 0, position: new THREE.Vector3(), mode: 'IDLE' },
            rightHand: { present: false, fingers: 0, indexTip: new THREE.Vector3(), position: new THREE.Vector3(), mode: 'POINT' },
            isUltimateMode: false
        };
        this.initMediaPipe();
        this.initKeyboard();
    }

    initMediaPipe() {
        this.hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        this.hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        this.hands.onResults((results) => this.onHandResults(results));

        const video = document.getElementById('input-video');
        const camera = new Camera(video, {
            onFrame: async () => await this.hands.send({image: video}),
            width: 640, height: 480
        });
        camera.start().then(() => document.getElementById('loading').style.display = 'none');
    }

    initKeyboard() {
        window.addEventListener('keydown', (e) => this.onKeyDown(e));
    }

    onKeyDown(e) {
        // Hybrid Controls - Map keys to states
        // Space: Lottery Spin
        // Enter: Lottery Reveal
        if(e.code === 'Space') {
            app.logic.triggerLotterySpin();
        } else if (e.code === 'Enter') {
            app.logic.triggerLotteryReveal();
        }

        // Voting Keys
        if(e.key.toLowerCase() === 'a') app.logic.triggerVote('A');
        if(e.key.toLowerCase() === 'b') app.logic.triggerVote('B');

        // Numbers for Left Hand emulation
        if(['0','1','2','3','4','5'].includes(e.key)) {
            // Emulate Left Hand Logic? Or just direct overrides.
            // Let's use it as direct mode triggers for now
            // But hands usually override continuously.
            // We need a "keyboard override" flag or just let frames overwrite it?
            // Since onHandResults runs every frame, it will overwrite manual state.
            // We'll handle key triggers in App Logic instead.
            app.logic.handleKeyCommand(e.key);
        }
    }

    _processHand(landmarks, isLogicalRight, isPhysicalRight) {
        // Helper: Calculate 2D distance between two landmarks
        const getDist = (i, j) => {
            const dx = landmarks[i].x - landmarks[j].x;
            const dy = landmarks[i].y - landmarks[j].y;
            return Math.sqrt(dx*dx + dy*dy);
        };

        // Robust Finger Counting (Orientation Independent)
        let fingers = 0;

        // Thumb: Check if Tip(4) is further from Pinky Knuckle(17) than the IP joint(3)
        // This indicates the thumb is extended OUTWARDS, regardless of hand rotation.
        if (getDist(4, 17) > getDist(3, 17)) fingers++;

        // Fingers 2-5: Check if Tip is further from Wrist(0) than the PIP joint (knuckle)
        // This works even if the hand is upside down or sideways.
        if (getDist(8, 0) > getDist(6, 0)) fingers++;   // Index
        if (getDist(12, 0) > getDist(10, 0)) fingers++; // Middle
        if (getDist(16, 0) > getDist(14, 0)) fingers++; // Ring
        if (getDist(20, 0) > getDist(18, 0)) fingers++; // Pinky

        // Coords
        const wx = (1 - landmarks[9].x - 0.5) * 800 * 1.5;
        const wy = -(landmarks[9].y - 0.5) * 600 * 1.5;
        const palmPos = new THREE.Vector3(wx, wy, 0);

        if (isLogicalRight) {
            this.state.rightHand.present = true;
            this.state.rightHand.fingers = fingers;
            this.state.rightHand.position.copy(palmPos);

            const tipX = (1 - landmarks[8].x - 0.5) * 800 * 1.5;
            const tipY = -(landmarks[8].y - 0.5) * 600 * 1.5;
            this.state.rightHand.indexTip.set(tipX, tipY, 0);
            this.state.rightHand.mode = (fingers === 5) ? 'NEBULA' : 'POINT';

            document.getElementById('right-status').innerText = `${this.state.rightHand.mode} (${fingers})`;
        } else {
            this.state.leftHand.present = true;
            this.state.leftHand.fingers = fingers;
            this.state.leftHand.position.copy(palmPos);

            // Mode mapping
            const modes = ['IDLE', 'HELLO', 'GEMINI', 'USEFUL', 'BYE', 'CATCH'];
            this.state.leftHand.mode = modes[fingers] || 'IDLE';

            document.getElementById('left-status').innerText = `${this.state.leftHand.mode} (${fingers})`;
        }
    }

    onHandResults(results) {
        this.state.leftHand.present = false;
        this.state.rightHand.present = false;

        if (results.multiHandLandmarks) {
            for (let index = 0; index < results.multiHandLandmarks.length; index++) {
                const landmarks = results.multiHandLandmarks[index];
                const label = results.multiHandedness[index].label;

                // 1. Determine Physical Hand (for default logic)
                // In selfie mode: Label 'Left' = User's Right Hand.
                const isPhysicalRight = (label === 'Left');

                // 2. Apply Logical Swap
                let isLogicalRight = isPhysicalRight;
                if (app.config.data.swapHands) {
                    isLogicalRight = !isLogicalRight;
                }

                this._processHand(landmarks, isLogicalRight, isPhysicalRight);
            }
        }
    }
}

// --- 5. UI MANAGER ---
class UIManager {
    togglePanel() {
        const p = document.getElementById('control-panel');
        p.style.display = (p.style.display === 'none') ? 'flex' : 'none';
    }

    switchTab(tabName) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
        document.getElementById(`tab-${tabName}`).classList.add('active');
        event.target.classList.add('active');
    }
}

// --- 6. APP LOGIC (Controller) ---
class App {
    constructor() {
        this.config = new ConfigManager();
        this.scene = new SceneManager();
        this.particleSystem = new ParticleSystem(this.config.data, this.scene.scene);
        this.input = new InputController();
        this.ui = new UIManager();
        this.logic = new AppLogic(this);

        this.time = 0;
        this.animate();
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.time += 0.01;

        // Update Logic
        this.logic.update();

        // Update Particles
        this.particleSystem.update(this.time, this.input.state);

        // Render
        // Camera drift
        this.scene.camera.position.x += (this.input.state.rightHand.position.x * 0.05 - this.scene.camera.position.x) * 0.05;
        this.scene.camera.position.y += (this.input.state.rightHand.position.y * 0.05 - this.scene.camera.position.y) * 0.05;
        this.scene.camera.lookAt(this.scene.scene.position);

        this.scene.render();

        // FPS
        document.getElementById('fps').innerText = Math.round(1 / (performance.now() - (this.lastTime || performance.now())) * 1000) || 60;
        this.lastTime = performance.now();
    }
}

class AppLogic {
    constructor(app) {
        this.app = app;
        this.previousLeftMode = 'IDLE';
        this.previousRightMode = 'POINT'; // Added track for right hand
        this.lotteryState = 'IDLE'; // IDLE, SPINNING, REVEALED
        this.lotteryTimer = null;
    }

    update() {
        const left = this.app.input.state.leftHand;
        const right = this.app.input.state.rightHand;
        const ps = this.app.particleSystem;
        const cfg = this.app.config.data;

        // 1. Left Hand Triggers
        if(left.present && left.mode !== this.previousLeftMode) {
             if(left.mode === 'HELLO') { ps.updateTargets('TEXT', cfg.commands[1]); ps.setColors(cfg.colors.blue); }
             else if(left.mode === 'GEMINI') { ps.updateTargets('TEXT', cfg.commands[2]); ps.setColors(cfg.colors.yellow); }
             else if(left.mode === 'USEFUL') { ps.updateTargets('TEXT', cfg.commands[3]); ps.setColors(cfg.colors.pink); }
             else if(left.mode === 'BYE') { ps.updateTargets('TEXT', cfg.commands[4]); ps.setColors(cfg.colors.green); }
             else if(left.mode === 'CATCH') { /* catch logic */ }
             this.previousLeftMode = left.mode;
        }

        // 2. Right Hand Triggers (Nebula Mode)
        const rightMode = right.present ? right.mode : 'POINT';
        if(rightMode !== this.previousRightMode) {
            if(rightMode === 'NEBULA') {
                ps.updateTargets('NEBULA');
            } else {
                // If returning from Nebula, restore left hand state if active
                if(left.present && left.mode !== 'IDLE') {
                    this.previousLeftMode = 'FORCE_UPDATE';
                }
            }
            this.previousRightMode = rightMode;
        }

        // 3. Ultimate Logic
        if(right.present && right.mode === 'NEBULA' && left.present && left.mode === 'CATCH') {
            if(!this.app.input.state.isUltimateMode) {
                this.app.input.state.isUltimateMode = true;
                ps.setColors(cfg.colors.orange);
            }
        } else {
            this.app.input.state.isUltimateMode = false;
        }

        // 3. Lottery Animation
        if(this.lotteryState === 'SPINNING') {
             // Randomly flash names
             if(Math.random() > 0.8) {
                 const list = cfg.lotteryList.split('\n');
                 const name = list[Math.floor(Math.random() * list.length)];
                 ps.updateTargets('TEXT', name);
                 ps.setColors(new THREE.Color(Math.random(), Math.random(), Math.random()));
             }
        }
    }

    handleKeyCommand(key) {
        const ps = this.app.particleSystem;
        const cfg = this.app.config.data;
        if(key === '1') { ps.updateTargets('TEXT', cfg.commands[1]); ps.setColors(cfg.colors.blue); }
        if(key === '2') { ps.updateTargets('TEXT', cfg.commands[2]); ps.setColors(cfg.colors.yellow); }
        if(key === '3') { ps.updateTargets('TEXT', cfg.commands[3]); ps.setColors(cfg.colors.pink); }
        if(key === '4') { ps.updateTargets('TEXT', cfg.commands[4]); ps.setColors(cfg.colors.green); }
        if(key === '0') { ps.updateTargets('NEBULA'); ps.setColors(cfg.colors.white); }
    }

    triggerLotterySpin() {
        if(this.lotteryState === 'SPINNING') return;
        this.lotteryState = 'SPINNING';
        this.app.particleSystem.updateTargets('NEBULA'); // Disperse first? Or keep flashing
        document.getElementById('mode-display').innerText = "MODE: LOTTERY SPIN";
    }

    triggerLotteryReveal() {
        if(this.lotteryState !== 'SPINNING') return;
        this.lotteryState = 'REVEALED';
        const list = this.app.config.data.lotteryList.split('\n');
        const winner = list[Math.floor(Math.random() * list.length)];

        this.app.particleSystem.updateTargets('TEXT', winner);
        this.app.particleSystem.setColors(this.app.config.data.colors.red);
        document.getElementById('mode-display').innerText = "WINNER: " + winner;
    }

    triggerVote(option) {
        let text = "";
        let color = null;
        if(option === 'A') {
            text = document.getElementById('vote-a').value;
            color = this.app.config.data.colors.blue;
        } else if(option === 'B') {
            text = document.getElementById('vote-b').value;
            color = this.app.config.data.colors.yellow;
        }

        if(text) {
            this.app.particleSystem.updateTargets('TEXT', text);
            this.app.particleSystem.setColors(color);
            document.getElementById('mode-display').innerText = "VOTE REVEAL: " + option;
        }
    }
}

// Start
const app = new App();

</script>
</body>
</html>
